# Flowsurface äºŒæ¬¡å¼€å‘å®æˆ˜æŒ‡å—

## ğŸ¯ å¿«é€Ÿå¯¼èˆª

| å¼€å‘ä»»åŠ¡ | ä¸»è¦æ–‡ä»¶ | éš¾åº¦ |
|---------|---------|-----|
| æ·»åŠ æ–°å›¾è¡¨ç±»å‹ | `src/chart/` + `data/chart/` | â­â­â­ |
| æ·»åŠ æ–°æŒ‡æ ‡ | `src/chart/indicator/` | â­â­ |
| æ·»åŠ æ–°äº¤æ˜“æ‰€ | `exchange/src/adapter/` | â­â­â­â­ |
| ä¿®æ”¹ä¸»é¢˜æ ·å¼ | `src/style.rs` + `data/config/theme.rs` | â­ |
| æ·»åŠ å›½é™…åŒ– | å…¨å±€ä¿®æ”¹ | â­â­â­â­â­ |
| æ•°æ®å±‚å‰¥ç¦» | `data/` + æ¶æ„é‡æ„ | â­â­â­â­â­ |

---

## ğŸ“Š å›¾è¡¨äºŒæ¬¡å¼€å‘è¯¦è§£

### å›¾è¡¨ç³»ç»Ÿæ ¸å¿ƒæ¦‚å¿µ

```rust
// å›¾è¡¨ç³»ç»Ÿçš„æ ¸å¿ƒæŠ½è±¡
pub trait Chart: PlotConstants + canvas::Program<Message> {
    type IndicatorKind: Indicator;  // å…³è”çš„æŒ‡æ ‡ç±»å‹
    
    fn state(&self) -> &ViewState;   // è§†å›¾çŠ¶æ€ï¼ˆç¼©æ”¾ã€å¹³ç§»ï¼‰
    fn mut_state(&mut self) -> &mut ViewState;
    
    fn invalidate_all(&mut self);    // é‡ç»˜æ‰€æœ‰
    fn invalidate_crosshair(&mut self); // é‡ç»˜åå­—çº¿
    
    fn view_indicators(&'_ self, enabled: &[Self::IndicatorKind]) -> Vec<Element<'_, Message>>;
    fn visible_timerange(&self) -> Option<(u64, u64)>;  // å¯è§æ—¶é—´èŒƒå›´
}
```

### å®æˆ˜æ¡ˆä¾‹ 1: æ·»åŠ  Depth Chart (æ·±åº¦å›¾)

#### æ­¥éª¤ 1: åˆ›å»ºæ•°æ®æ¨¡å‹ (`data/src/chart/depth.rs`)

```rust
use exchange::util::{Price, PriceStep};
use serde::{Deserialize, Serialize};
use std::collections::BTreeMap;

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct DepthChartConfig {
    pub max_levels: usize,      // æœ€å¤§æ˜¾ç¤ºæ¡£ä½
    pub cumulative: bool,       // æ˜¯å¦ç´¯ç§¯æ˜¾ç¤º
}

impl Default for DepthChartConfig {
    fn default() -> Self {
        Self {
            max_levels: 50,
            cumulative: true,
        }
    }
}

pub struct DepthDataPoint {
    pub bids: BTreeMap<Price, f32>,  // ä¹°å• (ä»·æ ¼ -> æ•°é‡)
    pub asks: BTreeMap<Price, f32>,  // å–å•
    pub mid_price: Price,            // ä¸­é—´ä»·
    pub timestamp: u64,              // æ—¶é—´æˆ³
}

impl DepthDataPoint {
    pub fn new() -> Self {
        Self {
            bids: BTreeMap::new(),
            asks: BTreeMap::new(),
            mid_price: Price::from_f32_lossy(0.0),
            timestamp: 0,
        }
    }
    
    // æ›´æ–°æ·±åº¦æ•°æ®
    pub fn update_from_depth(&mut self, depth: &exchange::depth::Depth, timestamp: u64) {
        self.bids = depth.bids.iter().map(|l| (l.price, l.qty)).collect();
        self.asks = depth.asks.iter().map(|l| (l.price, l.qty)).collect();
        self.timestamp = timestamp;
        
        // è®¡ç®—ä¸­é—´ä»·
        if let (Some(best_bid), Some(best_ask)) = (self.best_bid(), self.best_ask()) {
            self.mid_price = Price::from_units((best_bid.units + best_ask.units) / 2);
        }
    }
    
    pub fn best_bid(&self) -> Option<Price> {
        self.bids.keys().next_back().copied()
    }
    
    pub fn best_ask(&self) -> Option<Price> {
        self.asks.keys().next().copied()
    }
    
    // è®¡ç®—ç´¯ç§¯æ·±åº¦
    pub fn cumulative_bids(&self) -> Vec<(Price, f32)> {
        let mut cumulative = 0.0;
        self.bids.iter().rev().map(|(&price, &qty)| {
            cumulative += qty;
            (price, cumulative)
        }).collect()
    }
    
    pub fn cumulative_asks(&self) -> Vec<(Price, f32)> {
        let mut cumulative = 0.0;
        self.asks.iter().map(|(&price, &qty)| {
            cumulative += qty;
            (price, cumulative)
        }).collect()
    }
}
```

#### æ­¥éª¤ 2: æ³¨å†Œåˆ°å¸ƒå±€ç³»ç»Ÿ (`data/src/layout/pane.rs`)

```rust
#[derive(Debug, Clone, Deserialize, Serialize)]
#[serde(tag = "type")]
pub enum ContentKind {
    Heatmap(HeatmapConfig),
    Kline(KlineConfig),
    Comparison(ComparisonConfig),
    
    // âœ… æ·»åŠ æ–°çš„å›¾è¡¨ç±»å‹
    DepthChart(DepthChartConfig),
    
    Ladder(LadderConfig),
    TimeAndSales(TimeAndSalesConfig),
    Empty,
}

impl ContentKind {
    pub fn display_name(&self) -> &'static str {
        match self {
            Self::Heatmap(_) => "Heatmap",
            Self::Kline(_) => "Kline",
            Self::Comparison(_) => "Comparison",
            Self::DepthChart(_) => "Depth Chart",  // âœ… æ·»åŠ æ˜¾ç¤ºåç§°
            Self::Ladder(_) => "Ladder",
            Self::TimeAndSales(_) => "Time & Sales",
            Self::Empty => "Empty",
        }
    }
}
```

#### æ­¥éª¤ 3: å®ç°æ¸²æŸ“é€»è¾‘ (`src/chart/depth.rs`)

```rust
use crate::chart::{Chart, ViewState, PlotConstants, Caches, Message, Interaction};
use data::chart::depth::{DepthDataPoint, DepthChartConfig};
use exchange::TickerInfo;
use iced::widget::canvas::{self, Cache, Frame, Path, Stroke};
use iced::{Color, Point, Rectangle, Size, Theme, Vector};

pub struct DepthChart {
    state: ViewState,
    data: DepthDataPoint,
    config: DepthChartConfig,
    cache: Caches,
}

impl DepthChart {
    pub fn new(ticker_info: TickerInfo, config: DepthChartConfig) -> Self {
        let tick_size = ticker_info.min_ticksize.to_price_step();
        let decimals = ticker_info.min_ticksize.decimals();
        
        Self {
            state: ViewState::new(
                data::chart::Basis::Time(exchange::Timeframe::MS1000),
                tick_size,
                decimals,
                ticker_info,
                data::chart::ViewConfig::default(),
                10.0,  // cell_width
                5.0,   // cell_height
            ),
            data: DepthDataPoint::new(),
            config,
            cache: Caches::default(),
        }
    }
    
    pub fn update_depth(&mut self, depth: &exchange::depth::Depth) {
        let now = chrono::Utc::now().timestamp_millis() as u64;
        self.data.update_from_depth(depth, now);
        self.invalidate_all();
    }
}

// âœ… å®ç° Chart trait
impl Chart for DepthChart {
    type IndicatorKind = data::chart::indicator::KlineIndicator; // æˆ–è‡ªå®šä¹‰
    
    fn state(&self) -> &ViewState { &self.state }
    fn mut_state(&mut self) -> &mut ViewState { &mut self.state }
    
    fn invalidate_all(&mut self) {
        self.cache.clear_all();
    }
    
    fn invalidate_crosshair(&mut self) {
        self.cache.clear_crosshair();
    }
    
    fn view_indicators(&'_ self, _enabled: &[Self::IndicatorKind]) -> Vec<Element<'_, Message>> {
        vec![] // æ·±åº¦å›¾é€šå¸¸ä¸éœ€è¦é¢å¤–æŒ‡æ ‡
    }
    
    fn visible_timerange(&self) -> Option<(u64, u64)> {
        Some((self.data.timestamp, self.data.timestamp))
    }
    
    fn interval_keys(&self) -> Option<Vec<u64>> {
        None
    }
    
    fn autoscaled_coords(&self) -> Vector {
        Vector::default()
    }
    
    fn supports_fit_autoscaling(&self) -> bool {
        true
    }
    
    fn is_empty(&self) -> bool {
        self.data.bids.is_empty() && self.data.asks.is_empty()
    }
}

// âœ… å®ç° PlotConstants trait
impl PlotConstants for DepthChart {
    fn min_scaling(&self) -> f32 { 0.5 }
    fn max_scaling(&self) -> f32 { 3.0 }
    fn max_cell_width(&self) -> f32 { 50.0 }
    fn min_cell_width(&self) -> f32 { 2.0 }
    fn max_cell_height(&self) -> f32 { 20.0 }
    fn min_cell_height(&self) -> f32 { 1.0 }
    fn default_cell_width(&self) -> f32 { 10.0 }
}

// âœ… å®ç° Canvas ç»˜åˆ¶
impl canvas::Program<Message> for DepthChart {
    type State = Interaction;
    
    fn draw(
        &self,
        interaction: &Interaction,
        renderer: &iced::Renderer,
        theme: &Theme,
        bounds: Rectangle,
        cursor: iced::mouse::Cursor,
    ) -> Vec<canvas::Geometry> {
        let palette = theme.extended_palette();
        
        let content = self.cache.main.draw(renderer, bounds.size(), |frame| {
            let region = self.state.visible_region(bounds.size());
            
            // ç»˜åˆ¶ä¹°å•ï¼ˆç»¿è‰²ï¼‰
            self.draw_side(
                frame,
                &self.data.cumulative_bids(),
                region,
                palette.success.base.color,
                true,
            );
            
            // ç»˜åˆ¶å–å•ï¼ˆçº¢è‰²ï¼‰
            self.draw_side(
                frame,
                &self.data.cumulative_asks(),
                region,
                palette.danger.base.color,
                false,
            );
            
            // ç»˜åˆ¶ä¸­é—´ä»·çº¿
            self.draw_mid_price(frame, region, &palette);
        });
        
        vec![content]
    }
    
    fn update(
        &self,
        interaction: &mut Interaction,
        event: canvas::Event,
        bounds: Rectangle,
        cursor: iced::mouse::Cursor,
    ) -> Option<canvas::Action<Message>> {
        crate::chart::canvas_interaction(self, interaction, &event, bounds, cursor)
    }
}

// è¾…åŠ©ç»˜åˆ¶æ–¹æ³•
impl DepthChart {
    fn draw_side(
        &self,
        frame: &mut Frame,
        data: &[(exchange::util::Price, f32)],
        region: Rectangle,
        color: Color,
        is_bid: bool,
    ) {
        if data.is_empty() {
            return;
        }
        
        let max_qty = data.iter().map(|(_, qty)| *qty).fold(0.0f32, f32::max);
        
        let mut path_builder = canvas::path::Builder::new();
        
        for (i, (price, qty)) in data.iter().enumerate() {
            let x = if is_bid {
                region.width * (1.0 - qty / max_qty)
            } else {
                region.width * (qty / max_qty)
            };
            
            let price_f32 = price.to_f32_lossy();
            let y = self.state.price_to_y(*price);
            
            if i == 0 {
                path_builder.move_to(Point::new(x, y));
            } else {
                path_builder.line_to(Point::new(x, y));
            }
        }
        
        let path = path_builder.build();
        frame.stroke(&path, Stroke::default().with_color(color).with_width(2.0));
        
        // å¡«å……åŒºåŸŸ
        let mut fill_path = canvas::path::Builder::new();
        fill_path.move_to(Point::new(if is_bid { region.width } else { 0.0 }, 0.0));
        // ... (æ·»åŠ å¡«å……é€»è¾‘)
    }
    
    fn draw_mid_price(&self, frame: &mut Frame, region: Rectangle, palette: &iced::theme::palette::Extended) {
        let y = self.state.price_to_y(self.data.mid_price);
        
        frame.stroke(
            &Path::line(
                Point::new(0.0, y),
                Point::new(region.width, y),
            ),
            Stroke::default()
                .with_color(palette.background.base.text)
                .with_width(1.0),
        );
    }
}
```

#### æ­¥éª¤ 4: é›†æˆåˆ°é¢æ¿ç³»ç»Ÿ (`src/screen/dashboard/pane.rs`)

```rust
use crate::chart::depth::DepthChart;  // âœ… å¯¼å…¥æ–°å›¾è¡¨

pub enum Content {
    Heatmap(chart::heatmap::Heatmap),
    Kline(chart::kline::Kline),
    Comparison(chart::comparison::Comparison),
    
    // âœ… æ·»åŠ æ–°ç±»å‹
    DepthChart {
        chart: DepthChart,
        interaction: chart::Interaction,
    },
    
    Ladder(panel::ladder::Ladder),
    TimeAndSales(panel::timeandsales::TimeAndSales),
    Empty,
}

// åœ¨ update æ–¹æ³•ä¸­å¤„ç†æ·±åº¦æ•°æ®æ›´æ–°
impl State {
    pub fn update_depth(&mut self, depth: &exchange::depth::Depth) -> Task<Message> {
        match &mut self.content {
            Content::DepthChart { chart, .. } => {
                chart.update_depth(depth);
            }
            _ => {}
        }
        Task::none()
    }
}

// åœ¨ view æ–¹æ³•ä¸­æ·»åŠ æ¸²æŸ“é€»è¾‘
impl State {
    pub fn view(&self, /* ... */) -> Element<Message> {
        match &self.content {
            Content::DepthChart { chart, interaction } => {
                chart::view(chart, &[], timezone)
                    .map(move |msg| Message::Chart(pane_id, msg))
            }
            // ... å…¶ä»–ç±»å‹
        }
    }
}
```

#### æ­¥éª¤ 5: æ·»åŠ åˆ°èœå•å’Œ UI

```rust
// src/modal/pane/settings.rs - åœ¨å›¾è¡¨ç±»å‹é€‰æ‹©å™¨ä¸­æ·»åŠ 

impl Content {
    pub fn all_chart_types() -> Vec<(&'static str, ContentKind)> {
        vec![
            ("Heatmap", ContentKind::Heatmap(Default::default())),
            ("Kline", ContentKind::Kline(Default::default())),
            ("Comparison", ContentKind::Comparison(Default::default())),
            ("Depth Chart", ContentKind::DepthChart(Default::default())),  // âœ…
            ("Ladder", ContentKind::Ladder(Default::default())),
            ("Time & Sales", ContentKind::TimeAndSales(Default::default())),
        ]
    }
}
```

---

## ğŸŒ å›½é™…åŒ–å®ç°æ–¹æ¡ˆ

### æ–¹æ¡ˆ A: ä½¿ç”¨ rust-i18n (æ¨è)

#### 1. æ·»åŠ ä¾èµ–

```toml
# Cargo.toml
[dependencies]
rust-i18n = "3.0"
once_cell = "1.19"
```

#### 2. åˆ›å»ºç¿»è¯‘æ–‡ä»¶ç»“æ„

```
locales/
â”œâ”€â”€ en-US.yml
â”œâ”€â”€ zh-CN.yml
â””â”€â”€ ja-JP.yml
```

**locales/en-US.yml**:
```yaml
chart:
  waiting_for_data: "Waiting for data..."
  no_data: "No data available"
  autoscale: "Toggle autoscaling"
  
menu:
  settings: "Settings"
  layout: "Layout"
  audio: "Audio"
  
settings:
  theme: "Theme"
  timezone: "Time zone"
  sidebar_position: "Sidebar position"
  interface_scale: "Interface scale"
```

**locales/zh-CN.yml**:
```yaml
chart:
  waiting_for_data: "ç­‰å¾…æ•°æ®..."
  no_data: "æ— æ•°æ®"
  autoscale: "åˆ‡æ¢è‡ªåŠ¨ç¼©æ”¾"
  
menu:
  settings: "è®¾ç½®"
  layout: "å¸ƒå±€"
  audio: "éŸ³é¢‘"
  
settings:
  theme: "ä¸»é¢˜"
  timezone: "æ—¶åŒº"
  sidebar_position: "ä¾§è¾¹æ ä½ç½®"
  interface_scale: "ç•Œé¢ç¼©æ”¾"
```

#### 3. åˆå§‹åŒ– i18n

```rust
// src/i18n.rs (æ–°å»ºæ–‡ä»¶)
use rust_i18n::i18n;

i18n!("locales", fallback = "en-US");

pub use rust_i18n::t;

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Language {
    English,
    SimplifiedChinese,
    Japanese,
}

impl Language {
    pub fn code(&self) -> &'static str {
        match self {
            Language::English => "en-US",
            Language::SimplifiedChinese => "zh-CN",
            Language::Japanese => "ja-JP",
        }
    }
    
    pub fn display_name(&self) -> &'static str {
        match self {
            Language::English => "English",
            Language::SimplifiedChinese => "ç®€ä½“ä¸­æ–‡",
            Language::Japanese => "æ—¥æœ¬èª",
        }
    }
}

pub fn set_language(lang: Language) {
    rust_i18n::set_locale(lang.code());
}

pub fn current_language() -> &'static str {
    rust_i18n::locale()
}
```

#### 4. ä¿®æ”¹ä»£ç ä½¿ç”¨ç¿»è¯‘

**ä¿®æ”¹å‰**:
```rust
// src/chart.rs
if chart.is_empty() {
    return center(text("Waiting for data...").size(16)).into();
}
```

**ä¿®æ”¹å**:
```rust
use crate::i18n::t;

if chart.is_empty() {
    return center(text(t!("chart.waiting_for_data")).size(16)).into();
}
```

#### 5. æ·»åŠ è¯­è¨€åˆ‡æ¢UI

```rust
// src/main.rs - åœ¨ Message æšä¸¾ä¸­æ·»åŠ 
#[derive(Debug, Clone)]
enum Message {
    // ... ç°æœ‰æ¶ˆæ¯
    LanguageChanged(crate::i18n::Language),
}

// åœ¨ update æ–¹æ³•ä¸­å¤„ç†
impl Flowsurface {
    fn update(&mut self, message: Message) -> Task<Message> {
        match message {
            Message::LanguageChanged(lang) => {
                crate::i18n::set_language(lang);
                // ä¿å­˜åˆ°é…ç½®
                self.config.language = lang;
            }
            // ...
        }
    }
}

// åœ¨è®¾ç½®ç•Œé¢æ·»åŠ é€‰æ‹©å™¨
fn settings_view(&self) -> Element<Message> {
    let language_picker = pick_list(
        [
            crate::i18n::Language::English,
            crate::i18n::Language::SimplifiedChinese,
            crate::i18n::Language::Japanese,
        ],
        Some(self.config.language),
        Message::LanguageChanged,
    );
    
    column![
        text(t!("settings.language")).size(14),
        language_picker,
    ]
    .spacing(12)
}
```

#### 6. éœ€è¦ç¿»è¯‘çš„å…³é”®ä½ç½®

| æ–‡ä»¶è·¯å¾„ | éœ€ç¿»è¯‘å†…å®¹ | æ•°é‡ä¼°è®¡ |
|---------|-----------|---------|
| `src/main.rs` | èœå•é¡¹ã€æŒ‰é’®æ–‡æœ¬ | ~30 |
| `src/chart.rs` | å›¾è¡¨æç¤ºã€æŒ‰é’® | ~10 |
| `src/modal/layout_manager.rs` | å¸ƒå±€ç®¡ç†æ–‡æœ¬ | ~15 |
| `src/modal/pane/settings.rs` | è®¾ç½®é€‰é¡¹ | ~25 |
| `src/screen/dashboard/sidebar.rs` | ä¾§è¾¹æ æ–‡æœ¬ | ~20 |
| `src/widget/toast.rs` | é€šçŸ¥æ¶ˆæ¯ | ~10 |
| **æ€»è®¡** | | **~110** |

---

## ğŸ—‚ï¸ æ•°æ®å±‚å‰¥ç¦»å®æˆ˜

### å½“å‰æ¶æ„é—®é¢˜

```rust
// âŒ é—®é¢˜ 1: data å±‚ç›´æ¥ä¾èµ– exchange ç±»å‹
// data/src/chart/heatmap.rs
impl DataPoint for HeatmapDataPoint {
    fn add_trade(&mut self, trade: &exchange::Trade, step: PriceStep) {
        // ...
    }
}

// âŒ é—®é¢˜ 2: GUI å±‚åŒæ—¶ä¾èµ– data å’Œ exchange
// src/chart/heatmap.rs
pub fn update_trades(&mut self, trades: &[exchange::Trade]) {
    // ...
}
```

### æ”¹è¿›æ–¹æ¡ˆ: ä½¿ç”¨ DTO å’Œ Trait æŠ½è±¡

#### æ­¥éª¤ 1: åˆ›å»ºé€šç”¨æ•°æ®ç±»å‹ (`data/src/dto.rs`)

```rust
// data/src/dto.rs (æ–°å»º)
use serde::{Deserialize, Serialize};

/// é€šç”¨äº¤æ˜“æ•°æ®ä¼ è¾“å¯¹è±¡
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub struct TradeDTO {
    pub timestamp: u64,
    pub price: f64,
    pub quantity: f64,
    pub is_sell: bool,
}

/// é€šç”¨ K çº¿æ•°æ®ä¼ è¾“å¯¹è±¡
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub struct KlineDTO {
    pub timestamp: u64,
    pub open: f64,
    pub high: f64,
    pub low: f64,
    pub close: f64,
    pub volume: f64,
}

/// é€šç”¨æ·±åº¦æ•°æ®ä¼ è¾“å¯¹è±¡
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DepthDTO {
    pub timestamp: u64,
    pub bids: Vec<(f64, f64)>,  // (price, quantity)
    pub asks: Vec<(f64, f64)>,
}

// è½¬æ¢ trait
pub trait FromExchangeTrade {
    fn from_exchange(trade: &exchange::Trade) -> Self;
}

impl FromExchangeTrade for TradeDTO {
    fn from_exchange(trade: &exchange::Trade) -> Self {
        Self {
            timestamp: trade.time,
            price: trade.price.to_f32_lossy() as f64,
            quantity: trade.qty as f64,
            is_sell: trade.is_sell,
        }
    }
}
```

#### æ­¥éª¤ 2: ä¿®æ”¹ data å±‚ä½¿ç”¨ DTO

```rust
// data/src/chart/heatmap.rs (ä¿®æ”¹å)
use crate::dto::TradeDTO;

impl DataPoint for HeatmapDataPoint {
    // âœ… ç°åœ¨åªä¾èµ– DTOï¼Œä¸ä¾èµ– exchange
    fn add_trade(&mut self, trade: &TradeDTO, step: PriceStep) {
        let grouped_price = Price::from_f64(trade.price).round_to_side_step(trade.is_sell, step);
        // ...
    }
}
```

#### æ­¥éª¤ 3: åœ¨ GUI å±‚åšè½¬æ¢

```rust
// src/screen/dashboard/pane.rs
impl State {
    pub fn update_trades(&mut self, trades: &[exchange::Trade]) -> Task<Message> {
        // âœ… åœ¨ GUI å±‚è½¬æ¢
        let trade_dtos: Vec<data::dto::TradeDTO> = trades
            .iter()
            .map(data::dto::TradeDTO::from_exchange)
            .collect();
        
        match &mut self.content {
            Content::Heatmap { chart, .. } => {
                chart.add_trades(&trade_dtos);
            }
            // ...
        }
        Task::none()
    }
}
```

#### æ­¥éª¤ 4: åˆ›å»ºæ•°æ®æœåŠ¡å±‚ (å¯é€‰ï¼Œæ›´å½»åº•çš„åˆ†å±‚)

```rust
// data/src/service/mod.rs (æ–°å»º)
pub mod chart_data_service;

// data/src/service/chart_data_service.rs
use crate::dto::{TradeDTO, KlineDTO};
use crate::chart::heatmap::HeatmapDataPoint;

/// å›¾è¡¨æ•°æ®æœåŠ¡ - å¤„ç†æ‰€æœ‰æ•°æ®è½¬æ¢å’Œèšåˆ
pub struct ChartDataService {
    aggregators: HashMap<uuid::Uuid, Box<dyn DataAggregator>>,
}

pub trait DataAggregator: Send + Sync {
    fn add_trade(&mut self, trade: &TradeDTO);
    fn get_data_range(&self, start: u64, end: u64) -> Vec<Box<dyn DataPoint>>;
}

impl ChartDataService {
    pub fn new() -> Self {
        Self {
            aggregators: HashMap::new(),
        }
    }
    
    pub fn register_aggregator(&mut self, id: uuid::Uuid, aggregator: Box<dyn DataAggregator>) {
        self.aggregators.insert(id, aggregator);
    }
    
    pub fn process_trades(&mut self, id: &uuid::Uuid, trades: &[TradeDTO]) {
        if let Some(aggregator) = self.aggregators.get_mut(id) {
            for trade in trades {
                aggregator.add_trade(trade);
            }
        }
    }
}
```

---

## ğŸ¨ ä¸»é¢˜ç³»ç»Ÿæ‰©å±•

### æ·»åŠ è‡ªå®šä¹‰é…è‰²æ–¹æ¡ˆ

```rust
// src/style.rs - æ·»åŠ è‡ªå®šä¹‰ä¸»é¢˜

pub fn custom_dark_theme() -> Theme {
    Theme::custom(
        "Custom Dark".to_string(),
        iced::theme::Palette {
            background: Color::from_rgb(0.11, 0.11, 0.13),
            text: Color::from_rgb(0.9, 0.9, 0.9),
            primary: Color::from_rgb(0.3, 0.6, 1.0),
            success: Color::from_rgb(0.2, 0.8, 0.4),
            danger: Color::from_rgb(0.9, 0.3, 0.3),
        },
    )
}

// åœ¨ main.rs ä¸­æ³¨å†Œ
impl Flowsurface {
    fn available_themes() -> Vec<Theme> {
        let mut themes = iced_core::Theme::ALL.to_vec();
        themes.push(style::custom_dark_theme());
        themes
    }
}
```

---

## ğŸš€ æ€§èƒ½ä¼˜åŒ–æŠ€å·§

### 1. Canvas ç¼“å­˜ä¼˜åŒ–

```rust
// src/chart/heatmap.rs
impl canvas::Program<Message> for Heatmap {
    fn draw(&self, /* ... */) -> Vec<canvas::Geometry> {
        // âœ… ä½¿ç”¨ç¼“å­˜é¿å…æ¯å¸§é‡ç»˜
        let main_content = self.cache.main.draw(renderer, bounds.size(), |frame| {
            // ä»…åœ¨æ•°æ®å˜åŒ–æ—¶é‡ç»˜
            self.draw_heatmap_cells(frame, region);
        });
        
        let crosshair = self.cache.crosshair.draw(renderer, bounds.size(), |frame| {
            // åå­—çº¿å•ç‹¬ç¼“å­˜ï¼Œç§»åŠ¨æ—¶ä¸é‡ç»˜ä¸»å†…å®¹
            if let Some(pos) = cursor.position_in(bounds) {
                self.draw_crosshair(frame, pos);
            }
        });
        
        vec![main_content, crosshair]
    }
}
```

### 2. æ•°æ®è£å‰ª - åªæ¸²æŸ“å¯è§åŒºåŸŸ

```rust
impl Heatmap {
    fn draw_heatmap_cells(&self, frame: &mut Frame, region: Rectangle) {
        // âœ… è®¡ç®—å¯è§èŒƒå›´
        let (earliest, latest) = self.state.interval_range(&region);
        let (highest, lowest) = self.state.price_range(&region);
        
        // åªéå†å¯è§æ•°æ®
        for (&time, datapoint) in self.data.range(earliest..=latest) {
            for trade in &datapoint.grouped_trades {
                if trade.price >= lowest && trade.price <= highest {
                    // ç»˜åˆ¶...
                }
            }
        }
    }
}
```

### 3. ä½¿ç”¨é«˜æ•ˆæ•°æ®ç»“æ„

```rust
// âŒ ä½æ•ˆ: ä½¿ç”¨ Vec é¢‘ç¹æŸ¥æ‰¾
pub struct Data {
    trades: Vec<(u64, Trade)>,  // æ¯æ¬¡æŸ¥æ‰¾ O(n)
}

// âœ… é«˜æ•ˆ: ä½¿ç”¨ BTreeMap
use std::collections::BTreeMap;

pub struct Data {
    trades: BTreeMap<u64, Trade>,  // æŸ¥æ‰¾ O(log n)ï¼ŒèŒƒå›´æŸ¥è¯¢é«˜æ•ˆ
}

impl Data {
    fn range(&self, start: u64, end: u64) -> impl Iterator<Item = (&u64, &Trade)> {
        self.trades.range(start..=end)
    }
}
```

---

## ğŸ§ª æµ‹è¯•å®æˆ˜

### å•å…ƒæµ‹è¯•ç¤ºä¾‹

```rust
// data/src/chart/heatmap.rs

#[cfg(test)]
mod tests {
    use super::*;
    use crate::dto::TradeDTO;
    
    #[test]
    fn test_heatmap_data_aggregation() {
        let mut datapoint = HeatmapDataPoint::new();
        
        let trade = TradeDTO {
            timestamp: 1000000,
            price: 50000.0,
            quantity: 0.5,
            is_sell: false,
        };
        
        datapoint.add_trade(&trade, PriceStep::from_f32(1.0));
        
        assert_eq!(datapoint.buy_sell.0, 0.5);
        assert_eq!(datapoint.buy_sell.1, 0.0);
    }
    
    #[test]
    fn test_price_grouping() {
        let mut datapoint = HeatmapDataPoint::new();
        
        // æ·»åŠ ç›¸è¿‘ä»·æ ¼çš„äº¤æ˜“ï¼Œåº”è¯¥è¢«åˆ†ç»„
        for i in 0..5 {
            datapoint.add_trade(&TradeDTO {
                timestamp: 1000000 + i * 1000,
                price: 50000.0 + i as f64 * 0.1,
                quantity: 0.1,
                is_sell: false,
            }, PriceStep::from_f32(1.0));
        }
        
        // éªŒè¯åˆ†ç»„æ•°é‡
        assert!(datapoint.grouped_trades.len() <= 5);
    }
}

// è¿è¡Œæµ‹è¯•
// cargo test --package flowsurface-data
```

### é›†æˆæµ‹è¯•ç¤ºä¾‹

```rust
// tests/integration_test.rs

use flowsurface_exchange as exchange;
use flowsurface_data as data;

#[tokio::test]
async fn test_binance_connection() {
    let ticker = exchange::Ticker::new("BTCUSDT", exchange::adapter::Exchange::BinanceLinear);
    let config = exchange::adapter::StreamConfig {
        ticker,
        kind: exchange::adapter::StreamKind::Depth(/* ... */),
    };
    
    // æµ‹è¯•è¿æ¥
    let mut stream = exchange::connect::connect_stream(config).await.unwrap();
    
    // æ¥æ”¶ä¸€ä¸ªäº‹ä»¶
    if let Some(event) = stream.next().await {
        match event {
            exchange::Event::Connected(_) => { /* OK */ }
            exchange::Event::DepthReceived(_, _, _, _) => { /* OK */ }
            _ => panic!("Unexpected event"),
        }
    }
}
```

---

## ğŸ“š å¸¸ç”¨ä»£ç ç‰‡æ®µ

### 1. æ·»åŠ æ–°çš„çª—æ ¼æ“ä½œ

```rust
// src/screen/dashboard/pane.rs
#[derive(Debug, Clone)]
pub enum Message {
    // ... ç°æœ‰æ¶ˆæ¯
    CustomAction(uuid::Uuid),  // âœ… æ·»åŠ è‡ªå®šä¹‰æ“ä½œ
}

impl State {
    fn update(&mut self, message: Message) -> Task<Message> {
        match message {
            Message::CustomAction(id) => {
                // å¤„ç†é€»è¾‘
                Task::none()
            }
            // ...
        }
    }
}
```

### 2. æ·»åŠ é”®ç›˜å¿«æ·é”®

```rust
// src/main.rs
impl Flowsurface {
    fn subscription(&self) -> Subscription<Message> {
        let hotkeys = keyboard::listen().filter_map(|event| {
            let keyboard::Event::KeyPressed { key, modifiers, .. } = event else {
                return None;
            };
            
            match key.as_ref() {
                keyboard::Key::Named(keyboard::key::Named::Escape) => {
                    Some(Message::GoBack)
                }
                // âœ… æ·»åŠ æ–°å¿«æ·é”®
                keyboard::Key::Character("r") if modifiers.command() => {
                    Some(Message::Refresh)
                }
                keyboard::Key::Character("s") if modifiers.command() => {
                    Some(Message::SaveLayout)
                }
                _ => None,
            }
        });
        
        Subscription::batch(vec![/* ... */, hotkeys])
    }
}
```

### 3. æ·»åŠ è‡ªå®šä¹‰é€šçŸ¥

```rust
// src/widget/toast.rs
use iced::Color;

impl Toast {
    pub fn info(message: String) -> Self {
        Self {
            message,
            color: Color::from_rgb(0.3, 0.6, 1.0),
        }
    }
    
    pub fn success(message: String) -> Self {
        Self {
            message,
            color: Color::from_rgb(0.2, 0.8, 0.4),
        }
    }
    
    pub fn error(message: String) -> Self {
        Self {
            message,
            color: Color::from_rgb(0.9, 0.3, 0.3),
        }
    }
    
    // âœ… æ·»åŠ è‡ªå®šä¹‰ç±»å‹
    pub fn warning(message: String) -> Self {
        Self {
            message,
            color: Color::from_rgb(1.0, 0.7, 0.0),
        }
    }
}

// ä½¿ç”¨
self.notifications.push(Toast::warning("æ•°æ®å»¶è¿Ÿè­¦å‘Š".to_string()));
```

---

## ğŸ” è°ƒè¯•æŠ€å·§

### 1. å¯ç”¨è¯¦ç»†æ—¥å¿—

```rust
// src/logger.rs
pub fn setup(debug: bool) -> Result<(), fern::InitError> {
    let level = if debug {
        log::LevelFilter::Debug  // âœ… Debug æ¨¡å¼æ˜¾ç¤ºæ›´å¤šä¿¡æ¯
    } else {
        log::LevelFilter::Info
    };
    
    fern::Dispatch::new()
        .format(|out, message, record| {
            out.finish(format_args!(
                "[{}][{}] {}",
                chrono::Local::now().format("%H:%M:%S"),
                record.level(),
                message
            ))
        })
        .level(level)
        .level_for("wgpu", log::LevelFilter::Warn)  // è¿‡æ»¤å™ªéŸ³æ—¥å¿—
        .chain(std::io::stdout())
        .apply()?;
    
    Ok(())
}

// åœ¨ä»£ç ä¸­ä½¿ç”¨
log::debug!("Chart bounds: {:?}", bounds);
log::info!("Received {} trades", trades.len());
log::warn!("Data lag detected: {}ms", lag);
log::error!("Failed to parse ticker: {}", e);
```

### 2. æ€§èƒ½åˆ†æ

```rust
// ä½¿ç”¨ Instant æµ‹é‡æ€§èƒ½
use std::time::Instant;

impl Heatmap {
    fn update_data(&mut self, trades: &[Trade]) {
        let start = Instant::now();
        
        // æ‰§è¡Œæ“ä½œ...
        
        let elapsed = start.elapsed();
        if elapsed.as_millis() > 16 {  // > 1å¸§æ—¶é—´
            log::warn!("Slow update: {:?}", elapsed);
        }
    }
}
```

### 3. ä½¿ç”¨ cargo å·¥å…·

```bash
# æ€§èƒ½åˆ†æ
cargo flamegraph --bin flowsurface

# å†…å­˜æ³„æ¼æ£€æµ‹
cargo valgrind --bin flowsurface

# ä»£ç è¦†ç›–ç‡
cargo tarpaulin --out Html

# ä¾èµ–æ ‘åˆ†æ
cargo tree --depth 2
```

---

## ğŸ“– æ¨èèµ„æº

- **iced å®˜æ–¹æŒ‡å—**: https://book.iced.rs/
- **Rust å¼‚æ­¥ç¼–ç¨‹**: https://rust-lang.github.io/async-book/
- **WebSocket åè®®**: https://datatracker.ietf.org/doc/html/rfc6455
- **äº¤æ˜“æ‰€ API æ–‡æ¡£**:
  - Binance: https://binance-docs.github.io/apidocs/
  - Bybit: https://bybit-exchange.github.io/docs/
  - OKX: https://www.okx.com/docs-v5/

---

**æœ€åæ›´æ–°**: 2025-12-25  
**é€‚ç”¨ç‰ˆæœ¬**: Flowsurface v0.8.6+

ç¥å¼€å‘é¡ºåˆ©ï¼ğŸš€

